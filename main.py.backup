# -*- coding: utf-8 -*-
"""
Hybrid UI Automation Script - ä¸»æ§åˆ¶è…³æœ¬
æ•´åˆæ‰€æœ‰æ¨¡çµ„ï¼Œå¯¦ä½œå®Œæ•´çš„è‡ªå‹•åŒ–æµç¨‹æ§åˆ¶
"""

import time
import sys
from pathlib import Path
from typing import List, Dict, Optional
from datetime import datetime

# è¨­å®šæ¨¡çµ„æœå°‹è·¯å¾‘
sys.path.append(str(Path(__file__).parent))
sys.path.append(str(Path(__file__).parent.parent))

# å°å…¥æ‰€æœ‰æ¨¡çµ„
from config.config import config
from src.logger import get_logger, create_project_logger
from src.project_manager import ProjectManager, ProjectInfo
from src.cursor_controller import CursorController
from src.copilot_handler import CopilotHandler
from src.image_recognition import ImageRecognition
from src.ui_manager import UIManager
from src.error_handler import (
    ErrorHandler, RetryHandler, RecoveryManager,
    AutomationError, ErrorType, RecoveryAction
)

class HybridUIAutomationScript:
    """æ··åˆå¼ UI è‡ªå‹•åŒ–è…³æœ¬ä¸»æ§åˆ¶å™¨"""
    
    def __init__(self):
        """åˆå§‹åŒ–ä¸»æ§åˆ¶å™¨"""
        self.logger = get_logger("MainController")
        
        # åˆå§‹åŒ–å„å€‹æ¨¡çµ„
        self.project_manager = ProjectManager()
        self.vscode_controller = CursorController()
        self.error_handler = ErrorHandler()
        self.copilot_handler = CopilotHandler(self.error_handler)  # å‚³å…¥ error_handler
        self.image_recognition = ImageRecognition()
        self.retry_handler = RetryHandler(self.error_handler)
        self.recovery_manager = RecoveryManager()
        self.ui_manager = UIManager()
        
        # åŸ·è¡Œé¸é …
        self.use_smart_wait = True  # é è¨­ä½¿ç”¨æ™ºèƒ½ç­‰å¾…
        self.interaction_settings = None  # å„²å­˜äº’å‹•è¨­å®š
        
        # åŸ·è¡Œçµ±è¨ˆ
        self.total_projects = 0
        self.processed_projects = 0
        self.successful_projects = 0
        self.failed_projects = 0
        self.skipped_projects = 0
        self.start_time = None
        
        self.logger.info("æ··åˆå¼ UI è‡ªå‹•åŒ–è…³æœ¬åˆå§‹åŒ–å®Œæˆ")
    
    def run(self) -> bool:
        """
        åŸ·è¡Œå®Œæ•´çš„è‡ªå‹•åŒ–æµç¨‹
        
        Returns:
            bool: åŸ·è¡Œæ˜¯å¦æˆåŠŸ
        """
        try:
            self.start_time = time.time()
            self.logger.create_separator("é–‹å§‹åŸ·è¡Œè‡ªå‹•åŒ–è…³æœ¬")
            
            # é¡¯ç¤ºé¸é …å°è©±æ¡†
            reset_selected, self.use_smart_wait = self.ui_manager.show_options_dialog()
            
            # æ¯æ¬¡åŸ·è¡Œéƒ½é¡¯ç¤ºäº’å‹•è¨­å®šé¸é …
            self._show_interaction_settings_dialog()
            
            # å¦‚æœé¸æ“‡é‡ç½®ï¼ŒåŸ·è¡Œé‡ç½®è…³æœ¬
            if reset_selected:
                self.logger.info("ä½¿ç”¨è€…é¸æ“‡åŸ·è¡Œå°ˆæ¡ˆç‹€æ…‹é‡ç½®")
                if not self.ui_manager.execute_reset_if_needed(True):
                    self.logger.error("é‡ç½®å°ˆæ¡ˆç‹€æ…‹å¤±æ•—")
                    return False
            
            self.logger.info(f"ä½¿ç”¨è€…é¸æ“‡{'å•Ÿç”¨' if self.use_smart_wait else 'åœç”¨'}æ™ºèƒ½ç­‰å¾…åŠŸèƒ½")
            
            # å‰ç½®æª¢æŸ¥
            if not self._pre_execution_checks():
                return False
            
            # æƒæå°ˆæ¡ˆ
            projects = self.project_manager.scan_projects()
            if not projects:
                self.logger.error("æ²’æœ‰æ‰¾åˆ°ä»»ä½•å°ˆæ¡ˆï¼ŒçµæŸåŸ·è¡Œ")
                return False
            
            self.total_projects = len(projects)
            self.logger.info(f"ç¸½å…±ç™¼ç¾ {self.total_projects} å€‹å°ˆæ¡ˆ")
            
            # å–å¾—å¾…è™•ç†å°ˆæ¡ˆ
            pending_projects = self.project_manager.get_pending_projects()
            if not pending_projects:
                self.logger.info("æ‰€æœ‰å°ˆæ¡ˆéƒ½å·²è™•ç†å®Œæˆ")
                return True
            
            self.logger.info(f"å¾…è™•ç†å°ˆæ¡ˆ: {len(pending_projects)} å€‹")
            
            # ç›´æ¥è™•ç†æ‰€æœ‰å°ˆæ¡ˆ
            all_projects = self.project_manager.get_all_pending_projects()
            self.logger.info(f"é–‹å§‹è™•ç† {len(all_projects)} å€‹å°ˆæ¡ˆ")
            
            # åŸ·è¡Œæ‰€æœ‰å°ˆæ¡ˆ
            if not self._process_all_projects(all_projects):
                self.logger.warning("å°ˆæ¡ˆè™•ç†éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤")
            
            # æª¢æŸ¥æ˜¯å¦æ”¶åˆ°ä¸­æ–·è«‹æ±‚
            if self.error_handler.emergency_stop_requested:
                self.logger.warning("æ”¶åˆ°ä¸­æ–·è«‹æ±‚ï¼Œåœæ­¢è™•ç†")
            
            self.logger.info("æ‰€æœ‰å°ˆæ¡ˆè™•ç†å®Œæˆ")
            
            # è™•ç†å¤±æ•—çš„å°ˆæ¡ˆï¼ˆé‡è©¦ï¼‰
            if not self.error_handler.emergency_stop_requested:
                self._handle_failed_projects()
            
            # ç”Ÿæˆæœ€çµ‚å ±å‘Š
            if not self.error_handler.emergency_stop_requested:
                self._generate_final_report()
            
            return True
            
        except KeyboardInterrupt:
            self.logger.warning("æ”¶åˆ° Ctrl+C ä¸­æ–·è«‹æ±‚")
            self.error_handler.emergency_stop_requested = True
            return False
        except Exception as e:
            recovery_action = self.error_handler.handle_error(e, "ä¸»æµç¨‹åŸ·è¡Œ")
            if recovery_action == RecoveryAction.ABORT:
                self.logger.critical("ä¸»æµç¨‹åŸ·è¡Œå¤±æ•—ï¼Œä¸­æ­¢è‡ªå‹•åŒ–")
                return False
            else:
                self.logger.warning("ä¸»æµç¨‹é‡åˆ°éŒ¯èª¤ä½†å˜—è©¦ç¹¼çºŒåŸ·è¡Œ")
                return False
        
        finally:
            # è…³æœ¬åŸ·è¡Œå®Œç•¢
            pass
    
    def _show_interaction_settings_dialog(self):
        """é¡¯ç¤ºäº’å‹•è¨­å®šå°è©±æ¡†"""
        try:
            from src.interaction_settings_ui import show_interaction_settings
            self.logger.info("é¡¯ç¤ºå¤šè¼ªäº’å‹•è¨­å®šä»‹é¢")
            settings = show_interaction_settings()
            
            if settings is None:
                # ä½¿ç”¨è€…å–æ¶ˆäº†è¨­å®š
                self.logger.info("ä½¿ç”¨è€…å–æ¶ˆäº†äº’å‹•è¨­å®šï¼ŒçµæŸè…³æœ¬åŸ·è¡Œ")
                sys.exit(0)  # ç›´æ¥é€€å‡ºè…³æœ¬
            else:
                # å„²å­˜è¨­å®šä¸¦é‡æ–°åˆå§‹åŒ– CopilotHandler
                self.interaction_settings = settings
                self.copilot_handler = CopilotHandler(self.error_handler, settings)
                self.logger.info(f"æœ¬æ¬¡åŸ·è¡Œçš„äº’å‹•è¨­å®š: {settings}")
                
        except Exception as e:
            self.logger.error(f"é¡¯ç¤ºäº’å‹•è¨­å®šæ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
            # ç™¼ç”ŸéŒ¯èª¤æ™‚ä¹Ÿé€€å‡ºè…³æœ¬
            sys.exit(1)

    def _pre_execution_checks(self) -> bool:
        """
        åŸ·è¡Œå‰æª¢æŸ¥
        
        Returns:
            bool: æª¢æŸ¥æ˜¯å¦é€šé
        """
        try:
            self.logger.info("åŸ·è¡Œå‰ç½®æª¢æŸ¥...")
            
            # æª¢æŸ¥é…ç½®
            config.ensure_directories()
            
            # æª¢æŸ¥åœ–åƒè³‡æº
            if not self.image_recognition.validate_required_images():
                self.logger.warning("åœ–åƒè³‡æºé©—è­‰å¤±æ•—ï¼Œä½†ç¹¼çºŒåŸ·è¡Œï¼ˆä½¿ç”¨æ›¿ä»£æ–¹æ¡ˆï¼‰")
                # å¯ä»¥é¸æ“‡ä¸­æ­¢æˆ–ç¹¼çºŒ
                # return False
            
            # æª¢æŸ¥æ˜¯å¦æœ‰ Cursor åœ¨é‹è¡Œï¼ˆä½†ä¸å¼·åˆ¶é—œé–‰ï¼‰
            if self.vscode_controller.is_vscode_running():
                self.logger.info("æª¢æ¸¬åˆ° Cursor æ­£åœ¨é‹è¡Œï¼Œå°‡åœ¨å°ˆæ¡ˆè™•ç†å®Œæˆå¾Œé—œé–‰")
            else:
                self.logger.info("æœªæª¢æ¸¬åˆ° Cursor é‹è¡Œ")
            
            self.logger.info("âœ… å‰ç½®æª¢æŸ¥å®Œæˆ")
            return True
            
        except Exception as e:
            self.logger.error(f"å‰ç½®æª¢æŸ¥å¤±æ•—: {str(e)}")
            return False
    
    def _process_all_projects(self, projects: List[ProjectInfo]) -> bool:
        """
        è™•ç†æ‰€æœ‰å°ˆæ¡ˆ
        
        Args:
            projects: å°ˆæ¡ˆåˆ—è¡¨
            
        Returns:
            bool: è™•ç†æ˜¯å¦æˆåŠŸ
        """
        try:
            # ä¿è­·åˆ—è¡¨å·²åœ¨åˆå§‹åŒ–æ™‚è¨­ç½®ï¼Œä¸éœ€è¦å‹•æ…‹æ›´æ–°
            # åªä¿è­·è…³æœ¬åŸ·è¡Œæ™‚çš„ Cursor IDEï¼Œä¸ä¿è­·è…³æœ¬é–‹å•Ÿçš„å°ˆæ¡ˆé€²ç¨‹
            
            start_time = time.time()
            total_success = 0
            total_failed = 0
            
            for i, project in enumerate(projects, 1):
                self.logger.info(f"è™•ç†å°ˆæ¡ˆ {i}/{len(projects)}: {project.name}")
                
                # æª¢æŸ¥æ˜¯å¦éœ€è¦ç·Šæ€¥åœæ­¢
                if self.error_handler.emergency_stop_requested:
                    self.logger.warning("æ”¶åˆ°ç·Šæ€¥åœæ­¢è«‹æ±‚ï¼Œä¸­æ­¢å°ˆæ¡ˆè™•ç†")
                    break
                
                # è™•ç†å–®ä¸€å°ˆæ¡ˆ
                success = self._process_single_project(project)
                
                if success:
                    total_success += 1
                    self.successful_projects += 1
                else:
                    total_failed += 1
                    self.failed_projects += 1
                
                self.processed_projects += 1
                
                # é …ç›®é–“çŸ­æš«ä¼‘æ¯
                time.sleep(2)
            
            # è™•ç†æ‘˜è¦
            elapsed = time.time() - start_time
            self.logger.info(f"å°ˆæ¡ˆè™•ç†å®Œæˆ: æˆåŠŸ {total_success}, å¤±æ•— {total_failed}, è€—æ™‚ {elapsed:.1f}ç§’")
            
            return True
            
        except Exception as e:
            self.logger.error(f"è™•ç†å°ˆæ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")
            return False
    
    def _process_single_project(self, project: ProjectInfo) -> bool:
        """
        è™•ç†å–®ä¸€å°ˆæ¡ˆ
        
        Args:
            project: å°ˆæ¡ˆè³‡è¨Š
            
        Returns:
            bool: è™•ç†æ˜¯å¦æˆåŠŸ
        """
        project_logger = None
        start_time = time.time()
        
        try:
            # æª¢æŸ¥æ˜¯å¦æ”¶åˆ°ä¸­æ–·è«‹æ±‚
            if self.error_handler.emergency_stop_requested:
                self.logger.warning(f"æ”¶åˆ°ä¸­æ–·è«‹æ±‚ï¼Œè·³éå°ˆæ¡ˆ: {project.name}")
                return False
            
            # å‰µå»ºå°ˆæ¡ˆå°ˆç”¨æ—¥èªŒ
            project_logger = create_project_logger(project.name)
            project_logger.log("é–‹å§‹è™•ç†å°ˆæ¡ˆ")
            
            # æ›´æ–°å°ˆæ¡ˆç‹€æ…‹ç‚ºè™•ç†ä¸­
            self.project_manager.update_project_status(project.name, "processing")
            
            # ä½¿ç”¨é‡è©¦æ©Ÿåˆ¶è™•ç†å°ˆæ¡ˆ
            success, result = self.retry_handler.retry_with_backoff(
                self._execute_project_automation,
                max_attempts=config.MAX_RETRY_ATTEMPTS,
                context=f"å°ˆæ¡ˆ {project.name}",
                project=project,
                project_logger=project_logger
            )
            
            # è¨ˆç®—è™•ç†æ™‚é–“
            processing_time = time.time() - start_time
            
            if success:
                # æ¨™è¨˜å°ˆæ¡ˆå®Œæˆ
                self.project_manager.mark_project_completed(project.name, processing_time)
                project_logger.success()
                self.error_handler.reset_consecutive_errors()
                return True
            else:
                # æ¨™è¨˜å°ˆæ¡ˆå¤±æ•—
                error_msg = result if isinstance(result, str) else "è™•ç†å¤±æ•—"
                self.project_manager.mark_project_failed(project.name, error_msg, processing_time)
                project_logger.failed(error_msg)
                return False
                
        except Exception as e:
            processing_time = time.time() - start_time
            error_msg = str(e)
            
            self.project_manager.mark_project_failed(project.name, error_msg, processing_time)
            
            if project_logger:
                project_logger.failed(error_msg)
            
            self.logger.error(f"è™•ç†å°ˆæ¡ˆ {project.name} æ™‚ç™¼ç”Ÿæœªæ•ç²çš„éŒ¯èª¤: {error_msg}")
            return False
    
    def _execute_project_automation(self, project: ProjectInfo, project_logger) -> bool:
        """
        åŸ·è¡Œå°ˆæ¡ˆè‡ªå‹•åŒ–çš„æ ¸å¿ƒé‚è¼¯
        
        Args:
            project: å°ˆæ¡ˆè³‡è¨Š
            project_logger: å°ˆæ¡ˆæ—¥èªŒè¨˜éŒ„å™¨
            
        Returns:
            bool: åŸ·è¡Œæ˜¯å¦æˆåŠŸ
        """
        try:
            # æª¢æŸ¥ä¸­æ–·è«‹æ±‚
            if self.error_handler.emergency_stop_requested:
                raise AutomationError("æ”¶åˆ°ä¸­æ–·è«‹æ±‚", ErrorType.USER_INTERRUPT)
            
            # æ­¥é©Ÿ1: é–‹å•Ÿå°ˆæ¡ˆ
            project_logger.log("é–‹å•Ÿ VS Code å°ˆæ¡ˆ")
            if not self.vscode_controller.open_project(project.path):
                raise AutomationError("ç„¡æ³•é–‹å•Ÿå°ˆæ¡ˆ", ErrorType.VSCODE_ERROR)
            
            # æª¢æŸ¥ä¸­æ–·è«‹æ±‚
            if self.error_handler.emergency_stop_requested:
                raise AutomationError("æ”¶åˆ°ä¸­æ–·è«‹æ±‚", ErrorType.USER_INTERRUPT)
            
            # æ­¥é©Ÿ2: æ¸…é™¤ Copilot è¨˜æ†¶
            project_logger.log("æ¸…é™¤ Copilot Chat è¨˜æ†¶")
            # ç²å–ä¿®æ”¹çµæœè™•ç†è¨­å®š
            modification_action = self.interaction_settings.get("copilot_chat_modification_action", config.COPILOT_CHAT_MODIFICATION_ACTION) if self.interaction_settings else config.COPILOT_CHAT_MODIFICATION_ACTION
            self.logger.info(f"ä¿®æ”¹çµæœè™•ç†è¨­å®š: {modification_action}")
            if not self.vscode_controller.clear_copilot_memory(modification_action):
                self.logger.warning("Copilot è¨˜æ†¶æ¸…é™¤å¤±æ•—ï¼Œä½†ç¹¼çºŒåŸ·è¡Œ")
            
            # æª¢æŸ¥ä¸­æ–·è«‹æ±‚
            if self.error_handler.emergency_stop_requested:
                raise AutomationError("æ”¶åˆ°ä¸­æ–·è«‹æ±‚", ErrorType.USER_INTERRUPT)
            
            # æ­¥é©Ÿ3: è™•ç† Copilot Chatï¼ˆæ ¹æ“šè¨­å®šåˆ¤æ–·æ˜¯å¦ä½¿ç”¨åè¦†äº’å‹•ï¼‰
            # ä½¿ç”¨äº’å‹•è¨­å®šæˆ–é è¨­å€¼
            interaction_enabled = self.interaction_settings.get("interaction_enabled", config.INTERACTION_ENABLED) if self.interaction_settings else config.INTERACTION_ENABLED
            max_rounds = self.interaction_settings.get("max_rounds", config.INTERACTION_MAX_ROUNDS) if self.interaction_settings else config.INTERACTION_MAX_ROUNDS
            
            if interaction_enabled:
                # ä½¿ç”¨åè¦†äº’å‹•åŠŸèƒ½
                project_logger.log(f"è™•ç† Copilot Chat (å•Ÿç”¨åè¦†äº’å‹•åŠŸèƒ½ï¼Œæœ€å¤§è¼ªæ•¸: {max_rounds})")
                success = self.copilot_handler.process_project_with_iterations(project.path, max_rounds)
                
                if not success:
                    raise AutomationError("Copilot åè¦†äº’å‹•è™•ç†å¤±æ•—", ErrorType.COPILOT_ERROR)
            else:
                # ä½¿ç”¨ä¸€èˆ¬äº’å‹•æ¨¡å¼
                project_logger.log(f"è™•ç† Copilot Chat (æ™ºèƒ½ç­‰å¾…: {'é–‹å•Ÿ' if self.use_smart_wait else 'é—œé–‰'})")
                success, error_msg = self.copilot_handler.process_project_complete(
                    project.path, use_smart_wait=self.use_smart_wait
                )
                
                if not success:
                    raise AutomationError(
                        error_msg or "Copilot è™•ç†å¤±æ•—", 
                        ErrorType.COPILOT_ERROR
                    )
            
            # æª¢æŸ¥ä¸­æ–·è«‹æ±‚
            if self.error_handler.emergency_stop_requested:
                raise AutomationError("æ”¶åˆ°ä¸­æ–·è«‹æ±‚", ErrorType.USER_INTERRUPT)
            
            # æ­¥é©Ÿ4: é©—è­‰çµæœ
            project_logger.log("é©—è­‰è™•ç†çµæœ")
            script_root = Path(__file__).parent  # è…³æœ¬æ ¹ç›®éŒ„
            execution_result_dir = script_root / "ExecutionResult" / "Success"
            project_name = Path(project.path).name
            project_result_dir = execution_result_dir / project_name
            
            # æª¢æŸ¥å¤šè¼ªäº’å‹•çµæœæª”æ¡ˆï¼ˆæ”¯æ´å¤šç¨®æ ¼å¼ï¼‰
            has_success_file = (project_result_dir.exists() and 
                              (any(project_result_dir.glob("*_ç¬¬*è¼ª.md")) or
                               any(project_result_dir.glob("*_ç¬¬*è¼ª_ç¬¬*è¡Œ.md"))))
            
            # èª¿è©¦ä¿¡æ¯
            has_files = len(list(project_result_dir.glob("*.md"))) if project_result_dir.exists() else 0
            self.logger.info(f"çµæœæª”æ¡ˆé©—è­‰ - ç›®éŒ„å­˜åœ¨: {project_result_dir.exists()}, "
                            f"æª”æ¡ˆæ•¸é‡: {has_files}, å¤šè¼ªäº’å‹•æª”æ¡ˆ: {has_success_file}")
            
            if not has_success_file:
                raise AutomationError("ç¼ºå°‘æˆåŠŸåŸ·è¡Œçµæœæª”æ¡ˆ", ErrorType.PROJECT_ERROR)
            
            # æ­¥é©Ÿ5: æ™ºèƒ½é—œé–‰å°ˆæ¡ˆï¼ˆç¢ºä¿ Copilot å›æ‡‰å®Œæˆï¼‰
            project_logger.log("æ™ºèƒ½é—œé–‰å°ˆæ¡ˆä¸¦æ¸…é™¤è¨˜æ†¶")
            if not self._smart_close_project():
                self.logger.warning("å°ˆæ¡ˆé—œé–‰å¤±æ•—ï¼Œä½†è™•ç†å·²å®Œæˆ")
            
            project_logger.log("å°ˆæ¡ˆè™•ç†å®Œæˆ")
            return True
            
        except AutomationError:
            raise
        except Exception as e:
            raise AutomationError(str(e), ErrorType.UNKNOWN_ERROR)
    
    def _smart_close_project(self) -> bool:
        """
        æ™ºèƒ½é—œé–‰å°ˆæ¡ˆï¼Œç¢ºä¿ Copilot å›æ‡‰å®Œæˆ
        
        Returns:
            bool: é—œé–‰æ˜¯å¦æˆåŠŸ
        """
        try:
            # åˆ¤æ–·æ˜¯å¦è™•æ–¼å¤šè¼ªäº’å‹•æ¨¡å¼
            is_iteration_mode = config.INTERACTION_ENABLED and config.INTERACTION_MAX_ROUNDS > 1
            
            # å¤šè¼ªäº’å‹•æ¨¡å¼éœ€è¦æ›´é•·çš„ç­‰å¾…æ™‚é–“
            if is_iteration_mode:
                self.logger.info("å¤šè¼ªäº’å‹•æ¨¡å¼ï¼Œé€²è¡Œé¡å¤–çš„ç©©å®šæœŸç­‰å¾…...")
                stabilization_time = 3  # ç§’
                time.sleep(stabilization_time)
            
            # åœ¨é—œé–‰å°ˆæ¡ˆå‰é€²è¡Œåœ–åƒè¾¨è­˜æµç¨‹è™•ç†ä¿å­˜å°è©±æ¡†
            self.logger.info("é—œé–‰å°ˆæ¡ˆå‰è™•ç†ä¿å­˜å°è©±æ¡†...")
            
            # ç²å–ä¿®æ”¹çµæœè™•ç†è¨­å®š
            modification_action = self.interaction_settings.get("copilot_chat_modification_action", config.COPILOT_CHAT_MODIFICATION_ACTION) if self.interaction_settings else config.COPILOT_CHAT_MODIFICATION_ACTION
            
            # åŸ·è¡Œåœ–åƒè¾¨è­˜æµç¨‹
            from src.image_recognition import handle_save_dialog_with_image_recognition
            dialog_handled = handle_save_dialog_with_image_recognition(modification_action)
            
            if dialog_handled:
                self.logger.info("ä¿å­˜å°è©±æ¡†è™•ç†å®Œæˆ")
            else:
                self.logger.info("æœªæª¢æ¸¬åˆ°ä¿å­˜å°è©±æ¡†æˆ–è™•ç†å¤±æ•—ï¼Œç¹¼çºŒé—œé–‰å°ˆæ¡ˆ")
            
            # ç›´æ¥èª¿ç”¨é—œé–‰å°ˆæ¡ˆ
            return self.vscode_controller.close_current_project(force=False)
            
        except Exception as e:
            self.logger.error(f"æ™ºèƒ½é—œé–‰å°ˆæ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")
            # ç™¼ç”ŸéŒ¯èª¤æ™‚ï¼Œå˜—è©¦å¼·åˆ¶é—œé–‰
            return self.vscode_controller.close_current_project(force=True)
    
    def _handle_failed_projects(self):
        """è™•ç†å¤±æ•—çš„å°ˆæ¡ˆï¼ˆé‡è©¦æ©Ÿåˆ¶ï¼‰"""
        try:
            retry_projects = self.project_manager.get_retry_projects()
            
            if not retry_projects:
                self.logger.info("æ²’æœ‰éœ€è¦é‡è©¦çš„å°ˆæ¡ˆ")
                return
            
            self.logger.create_separator(f"é‡è©¦å¤±æ•—å°ˆæ¡ˆ ({len(retry_projects)} å€‹)")
            
            for project in retry_projects:
                self.logger.info(f"é‡è©¦å°ˆæ¡ˆ: {project.name} (ç¬¬ {project.retry_count + 1} æ¬¡)")
                
                # é‡è¨­å°ˆæ¡ˆç‹€æ…‹ç‚ºå¾…è™•ç†
                self.project_manager.update_project_status(project.name, "pending")
                
                # é‡æ–°è™•ç†
                success = self._process_single_project(project)
                
                if success:
                    self.logger.info(f"âœ… å°ˆæ¡ˆ {project.name} é‡è©¦æˆåŠŸ")
                else:
                    self.logger.warning(f"âŒ å°ˆæ¡ˆ {project.name} é‡è©¦ä»ç„¶å¤±æ•—")
                
                time.sleep(5)  # é‡è©¦é–“ä¼‘æ¯
                
        except Exception as e:
            self.logger.error(f"è™•ç†é‡è©¦å°ˆæ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")
    
    def _generate_final_report(self):
        """ç”Ÿæˆæœ€çµ‚å ±å‘Š"""
        try:
            end_time = time.time()
            total_elapsed = end_time - self.start_time if self.start_time else 0
            
            # ç”Ÿæˆæ‘˜è¦
            self.logger.create_separator("åŸ·è¡Œå®Œæˆæ‘˜è¦")
            self.logger.batch_summary(
                self.total_projects,
                self.successful_projects,
                self.failed_projects,
                total_elapsed
            )
            
            # éŒ¯èª¤æ‘˜è¦
            error_summary = self.error_handler.get_error_summary()
            if error_summary.get("total_errors", 0) > 0:
                self.logger.warning(f"ç¸½éŒ¯èª¤æ¬¡æ•¸: {error_summary['total_errors']}")
                self.logger.warning(f"æœ€è¿‘éŒ¯èª¤: {error_summary['recent_errors']}")
            
            # ä¿å­˜å°ˆæ¡ˆæ‘˜è¦å ±å‘Š
            report_file = self.project_manager.save_summary_report()
            if report_file:
                self.logger.info(f"è©³ç´°å ±å‘Šå·²å„²å­˜: {report_file}")
            
        except Exception as e:
            self.logger.error(f"ç”Ÿæˆæœ€çµ‚å ±å‘Šæ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")
    

def main():
    """ä¸»å‡½æ•¸"""
    try:
        print("=" * 60)
        print("æ··åˆå¼ UI è‡ªå‹•åŒ–è…³æœ¬")
        print("Hybrid UI Automation Script")
        print("=" * 60)
        
        # å‰µå»ºä¸¦é‹è¡Œè…³æœ¬
        automation_script = HybridUIAutomationScript()
        success = automation_script.run()
        
        if success:
            print("âœ… è‡ªå‹•åŒ–è…³æœ¬åŸ·è¡Œå®Œæˆ")
            return 0
        else:
            print("âŒ è‡ªå‹•åŒ–è…³æœ¬åŸ·è¡Œå¤±æ•—")
            return 1
            
    except KeyboardInterrupt:
        print("\nâ¹ï¸ ç”¨æˆ¶ä¸­æ–·åŸ·è¡Œ")
        return 2
    except Exception as e:
        print(f"ğŸ’¥ ç™¼ç”Ÿæœªé æœŸçš„éŒ¯èª¤: {str(e)}")
        return 3

if __name__ == "__main__":
    exit(main())